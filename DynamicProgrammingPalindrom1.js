// Динамическое программирование для решения проблемы алгоритма массива палиндрома
// Описание:
// Для данного массива a [], состоящего из положительных целых чисел, если последовательность чисел после перевёртывания a в точности такая же, как a, мы называем этот массив «палиндромом».
// Например, обратный порядок [1, 2, 3, 2, 1] - это он сам, поэтому это массив палиндромов; в то время как порядок [1, 2, 3, 1, 2] Обратный порядок [2, 1, 3, 2, 1], так что это не массив палиндрома.
// Для любого массива положительных целых чисел, если мы вставим некоторые положительные целые числа в определенные позиции, мы всегда сможем построить массив палиндрома.
// Введите массив положительных целых чисел, и вам потребуется вставить некоторые числа, чтобы сделать его массивом палиндромов, а сумма всех чисел в массиве должна быть как можно меньше.
// Выведите сумму элементов вставленного массива.
//     Например, Для массива[1, 2, 3, 1, 2] мы можем вставить две единицы, чтобы превратить его в массив палиндрома[1, 2, 1, 3, 1, 2, 1],
//         этот метод преобразования массива sum - наименьшее значение, равное 11, поэтому на выходе будет 11.

// Входные данные состоят из двух строк: первая строка содержит положительное целое число L,
// которое представляет длину массива a.Вторая строка содержит L положительных целых чисел, представляющих массив a.
// Для 40 % данных: 1 < L <= 100 Количество цифр, которые необходимо вставить при выполнении условий, не более 2. Для 100 % данных: 1 < L <= 1 000 0 < a[i] <= 1 000 000
// Нет ограничений на количество чисел, которые необходимо вставить при выполнении условий.
// Описание выхода:
// выводит целое число, которое представляет минимальное значение цифровой суммы массива a после вставки нескольких положительных целых чисел в палиндром.

const num = 5; // Длина массива
const arr = [1, 2, 3, 1, 2];

function find(num, arr) {
   let dp = []; // Сохраняем подмассив в начале i-го элемента и в конце j-го элемента, чтобы сформировать сумму массива палиндрома наименьшей суммы

   for (let i = num - 1; i >= 0; i--) {
      dp[i] = new Array();
      dp[i][i] = arr[i];

      // Разбиваем массив на малельние подмассивы и вычисляем наименьшую сумму элементов палиндрома для каждого подмассива
      // (Подмассив может состоять даже из одного элемента)
      for (let j = i + 1; j < num; j++) {
         if (arr[i] == arr[j]) {
            // Если i + 1 > j-1 означает, что числа i и j в это время смежны.
            // Итак, dp [i][j] = arr[i] + arr[j] = 2 * arr[i]
            if (i + 1 > j - 1) {
               dp[i][j] = 2 * arr[i];
            } else {
               dp[i][j] = dp[i + 1][j - 1] + 2 * arr[i];
            }
         } else {
            dp[i][j] = Math.min(dp[i + 1][j] + 2 * arr[i], dp[i][j - 1] + 2 * arr[j]);
         }
      }
   }
   return dp[0][num - 1];
}

console.log(find(num, arr));

// Rezult 11
